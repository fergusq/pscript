module core;

extern import "stdlib.h";

extern Int strcmp(Str a, Str b);
extern Void strcpy(Str d, Str s);
extern Void strcat(Str d, Str s);
extern Void sprintf(Str d, Str f, Int i);

// STRING

model String {
	Str toString();
}

extend Str with String {
	Str toString() {
		return this;
	}
}

extend Int with String {
	Str toString() {
		var str = new Char*(20);
		sprintf(str, "%d", this);
		return str;
	}
}

extend Bool with String {
	Str toString() {
		if (this) return "true";
		else return "false";
	}
}

extend Array<@T> with String {
	Str toString() {
		var str = "[";
		var i = 0;
		for (item in this) {
			if (i != 0) str = str ++ ", ";
			str = str ++ item;
			i = i + 1;
		}
		return str ++ "]";
	}
}

Char[] stringToArray(String str) {
	return new Array<Char> { str.size(), str.toString() as Char* }.copy();
}

// EQ

model Eq<@T> {
	Bool operator ==(@T t);
	Bool operator !=(@T t);
}

extend Str with Eq<String> {
	Bool operator ==(String t) {
		return strcmp(this, t.toString()) == 0;
	}
	Bool operator !=(String t) {
		return strcmp(this, t.toString()) != 0;
	}
}

extend String with Eq<String> {
	Bool operator ==(String t) {
		return this.toString() == t;
	}
	Bool operator !=(String t) {
		return this.toString() != t;
	}
}

extend Array<@T> with Eq<Array<@T>> {
	Bool operator ==(@T[] t) {
		if (this.len != t.len) return false;
		for (i in [0 .. this.len-1]) {
			if (this[i] != t[i]) return false;
		}
		return true;
	}
	Bool operator !=(@T[] t) {
		return !(this == t);
	}
}

// SUMMABLE

model Summable<@T> {
	$ operator ++(@T t);
	@T sumIdentity();
}

extend String with Summable<String> {
	String operator ++(String t) {
		return this.toString() ++ t;
	}
	
	String sumIdentity() {
		return this.sumIdentity();
	}
}

extend Str with Summable<String> {
	Str operator ++(String t) {
		var newString = new Char*(this.size()+t.size()+1);
		strcpy(newString, this);
		strcat(newString, t.toString());
		return newString;
	}
	String sumIdentity() {
		return "";
	}
}

extend Array<@T> with Summable<Array<@T>> {
	Array<@T> operator ++(Array<@T> a) {
		var arr = new @T[this.len + a.len];
		var i = 0;
		for (v in this) {
			arr[i] = v;
			i = i + 1;
		}
		for (v in a) {
			arr[i] = v;
			i = i + 1;
		}
		return arr;
	}
	Array<@T> sumIdentity() {
		return new @T[0];
	}
}

// HASSIZE

extern Int strlen(Str s);

model HasSize {
	Int size();
}

extend String with HasSize {
	Int size() {
		return this.toString().size();
	}
}

extend Str with HasSize {
	Int size() {
		return strlen(this);
	}
}

extend Array<@T> with HasSize {
	Int size() {
		return this.len;
	}
}

// APPENDABLE

model Appendable<@T> : CopyCollector<@T> {
	$ append(@T element);
}

extend Array<@T> with Appendable<@T> {
	@T[] append(@T item) {
		var newArray = new @T[this.len+1];
		for (i in [0 .. this.len-1]) {
			newArray[i] = this[i];
		}
		newArray[this.len] = item;
		return newArray;
	}
}

// PUSHABLE

model Pushable<@T> : Collector<@T> {
	Void push(@T element);
}

// PIPES

model Iterator<@T> : StreamSource<@T> {
	@T? next();
}

struct ArrayIterator<@T> {
	@T[] elements;
	Int location;
}

extend ArrayIterator<@T> with Iterator<@T> {
	@T? next() {
		if (this.location < this.elements.len) {
			this.location = this.location + 1;
			return just(this.elements[this.location - 1]);
		}
		else {
			return nothing();
		}
	}
}

const struct MappingIterator<@From, @To> {
	@From -> @To mappingFunction;
	Iterator<@From> source;
}

extend MappingIterator<@F, @T> with Iterator<@T> {
	@T? next() {
		match (this.source.next()) {
			Just(v) -> return just(this.mappingFunction.call(v));
		}
		return nothing();
	}
}

const struct FilteringIterator<@T> {
	@T->Bool predicate;
	Iterator<@T> source;
}

extend FilteringIterator<@T> with Iterator<@T> {
	@T? next() {
		while (true) {
			match (this.source.next()) {
				Just(item) -> {
					if (this.predicate.call(item))
						return just(item);
				}
				Nothing -> break;
			}
		}
		return nothing();
	}
}

struct LimitingIterator<@T> {
	Int limit;
	Iterator<@T> source;
	Int position;
}

extend LimitingIterator<@T> with Iterator<@T> {
	@T? next() {
		if (this.position >= this.limit)
			return nothing();
		this.position = this.position + 1;
		return this.source.next();
	}
}

model StreamSource<@T> {
	Iterator<@T> iterator();
}

extend Iterator<@T> with StreamSource<@T> {
	Iterator<@T> iterator() {
		return this;
	}
}

extend ArrayIterator<@T> with StreamSource<@T> {
	Iterator<@T> iterator() {
		return this;
	}
}

extend MappingIterator<@F, @T> with StreamSource<@T> {
	Iterator<@T> iterator() {
		return this;
	}
}

extend FilteringIterator<@T> with StreamSource<@T> {
	Iterator<@T> iterator() {
		return this;
	}
}

extend LimitingIterator<@T> with StreamSource<@T> {
	Iterator<@T> iterator() {
		return this;
	}
}

extend Array<@T> with StreamSource<@T> {
	Iterator<@T> iterator() {
		return new ArrayIterator<@T> { this, 0 };
	}
}

// STREAM OPERATION

model StreamOperation<@T, @U> {
	@U operator |(StreamSource<@T> source);
}

extend Func<@R, @P> with StreamOperation<@P, StreamSource<@R>> {
	StreamSource<@R> operator |(StreamSource<@P> source) {
		return new MappingIterator<@P, @R> { this, source.iterator() };
	}
}

const struct Filter<@T> {
	@T->Bool predicate;
}

extend Filter<@T> with StreamOperation<@T, StreamSource<@T>> {
	StreamSource<@T> operator |(StreamSource<@T> source) {
		return new FilteringIterator<@T> { this.predicate, source.iterator() };
	}
}

StreamOperation<@T, StreamSource<@T>> filter<@T>(@T->Bool predicate) {
	return new Filter<@T> { predicate };
}

const struct Limit<@T> {
	Int limit;
}

extend Limit<@T> with StreamOperation<@T, StreamSource<@T>> {
	StreamSource<@T> operator |(StreamSource<@T> source) {
		return new LimitingIterator<@T> { this.limit, source.iterator(), 0 };
	}
}

StreamOperation<@T, StreamSource<@T>> limit<@T>(Int number) {
	return new Limit<@T> { number };
}

const struct Forall<@T> {
	@T->Void callback;
}

extend Forall<@T> with StreamOperation<@T, Void> {
	Void operator |(StreamSource<@T> source) {
		var i = source.iterator();
		while (true) {
			match (i.next()) {
				Just(v) -> this.callback.call(v);
				Nothing -> break;
			}
		}
	}
}

StreamOperation<@T, Void> forAll<@T>(@T->Void callback) {
	return new Forall<@T> { callback };
}

struct Fold<@T, @U> {
	@U collection;
	(@U, @T)->@U collector;
}

extend Fold<@T, @U> with StreamOperation<@T, @U> {
	@U operator |(StreamSource<@T> source) {
		var i = source.iterator();
		while (true) {
			match (i.next()) {
				Just(v) -> this.collection = this.collector.call(this.collection, v);
				Nothing -> break;
			}
		}
		return this.collection;
	}
}

StreamOperation<@T, @U> fold<@T, @U>(@U collection, (@U, @T)->@U collector) {
	return new Fold<@T, @U> { collection, collector };
}

StreamOperation<@T, @U> appendTo<@T, @U>(@U collection) {
	return fold(collection, (@U u, @T t) -> @U { return u.append(t); });
}

StreamOperation<@T, @U> pushTo<@T, @U>(@U collection) {
	return fold(collection, (@U u, @T t) -> @U { u.push(t); return u; });
}

// COLLECTOR

model Collector<@T> {
	StreamOperation<@T, $> collect();
}

extend Array<@T> with CopyCollector<@T> {
	StreamOperation<@T, Array<@T>> collectToCopy() {
		return appendTo::<@T, Array<@T>>(this);
	}
}

model CopyCollector<@T> {
	StreamOperation<@T, $> collectToCopy();
}

extend CopyCollector<@T> with Collector<@T> {
	StreamOperation<@T, $> collect() {
		return this.collectToCopy();
	}
}

// COPYABLE

model Copyable {
	$ copy();
}

extend Array<@T> with Copyable {
	@T[] copy() {
		var newList = new @T[this.size()];
		for (i in [0 .. this.size()-1]) {
			newList[i] = this[i];
		}
		return newList;
	}
}

// CONTAINER

model Container<@T> : StreamSource<@T> {
	Bool contains(@T value);
}

extend Array<@T> with Container<@T> {
	Bool contains(@T value) {
		for (item in this) {
			if (item == value) return true;
		}
		return false;
	}
}

// STACK

model Stack<@T> : Pushable<@T> {
	@T pop();
}

// QUEUE

model Queue<@T> : Pushable<@T> {
	@T pull();
}

// LIST

model List<@T> : HasSize, Container<@T> {
	@T operator [](Int index);
	Void operator []=(Int index, @T value);
}

extend Array<@T> with List<@T> {
	[SuppressWarnings]
	@T operator [](Int index) {
		return this.ptr[index];
	}
	[SuppressWarnings]
	Void operator []=(Int index, @T value) {
		this.ptr[index] = value;
	}
}

// VARIABLE-SIZE LIST

model VariableSizeList<@T> : List<@T>, Stack<@T> {
	Void add(Int index, @T value);
	@T remove(Int index);
}

// ARRAYLIST

struct ArrayList<@T> {
	@T[] elements;
}

extend ArrayList<@T> with HasSize {
	Int size() {
		return this.elements.size();
	}
}

extend ArrayList<@T> with String {
	Str toString() {
		return "ArrayList { " ++ this.elements ++ " }";
	}
}

extend ArrayList<@T> with Eq<ArrayList<@T>> {
	Bool operator ==(ArrayList<@T> al) {
		return this.elements == al.elements;
	}
	Bool operator !=(ArrayList<@T> al) {
		return this.elements != al.elements;
	}
}

extend ArrayList<@T> with Container<@T> {
	Bool contains(@T value) {
		return this.elements.contains(value);
	}
}

extend ArrayList<@T> with List<@T> {
	@T operator [](Int index) {
		return this.elements[index];
	}
	Void operator []=(Int index, @T value) {
		this.elements[index] = value;
	}
}

extend ArrayList<@T> with Pushable<@T> {
	Void push(@T value) {
		this.elements = this.elements.append(value);
	}
}

extend ArrayList<@T> with Stack<@T> {
	@T pop() {
		return this.remove(this.size()-1);
	}
}

extend ArrayList<@T> with VariableSizeList<@T> {
	Void add(Int index, @T value) {
		var arr = new @T[this.size()+1];
		var i = 0;
		for (v in this.elements) {
			if (i < index)
				arr[i] = v;
			else if (i == index) {
				arr[i] = value;
				arr[i+1] = v;
			} else if (i > index)
				arr[i+1] = v;
			i = i + 1;
		}
		this.elements = arr;
	}
	@T remove(Int index) {
		var t = this[index];
		var arr = new @T[this.size()-1];
		var i = 0;
		for (v in this.elements) {
			if (i < index)
				arr[i] = v;
			else if (i > index)
				arr[i-1] = v;
			i = i + 1;
		}
		this.elements = arr;
		return t;
	}
}

extend ArrayList<@T> with Summable<ArrayList<@T>> {
	ArrayList<@T> operator ++(ArrayList<@T> l) {
		return new ArrayList<@T> { this.elements ++ l.elements };
	}
	
	ArrayList<@T> sumIdentity() {
		return new ArrayList<@T> { this.elements.sumIdentity() };
	}
}

extend ArrayList<@T> with Appendable<@T> {
	ArrayList<@T> append(@T value) {
		return new ArrayList<@T> { this.elements.append(value) };
	}
}

extend ArrayList<@T> with CopyCollector<@T> {
	StreamOperation<@T, ArrayList<@T>> collectToCopy() {
		return appendTo::<@T, ArrayList<@T>>(this);
	}
}

extend ArrayList<@T> with Collector<@T> {
	StreamOperation<@T, ArrayList<@T>> collect() {
		return pushTo::<@T, ArrayList<@T>>(this);
	}
}

extend ArrayList<@T> with StreamSource<@T> {
	Iterator<@T> iterator() {
		return new ArrayIterator<@T> { this.elements, 0 };
	}
}

extend ArrayList<@T> with Copyable {
	ArrayList<@T> copy() {
		return new ArrayList<@T> { this.elements.copy() };
	}
}

// OPTIONAL

model Optional<@T> : Container<@T> {
	@T orElse(@T value);
	@T orElseGet(()->@T getter);
	Bool isPresent();
}

// MAYBE

enum Maybe<@T> {
	Just(@T),
	Nothing
}

Maybe<@T> just<@T>(@T value) {
	return new Maybe<@T>::Just(value);
}

Maybe<@T> nothing<@T>() {
	return new Maybe<@T>::Nothing();
}

extend Maybe<@T> with Eq<Maybe<@T>> {
	Bool operator ==(Maybe<@T> al) {
		match (this) {
			Just(v1) -> match (al) {
				Just(v2) -> return true;
			}
			Nothing -> match (al) {
				Nothing -> return true;
			}
		}
		return false;
	}
	Bool operator !=(Maybe<@T> al) {
		return !(this == al);
	}
}

extend Maybe<@T> with Container<@T> {
	Bool contains(@T value) {
		match (this) {
			Just(v) -> return v == value;
		}
		return false;
	}
}

extend Maybe<@T> with StreamSource<@T> {
	Iterator<@T> iterator() {
		match (this) {
			Just(v) -> return new ArrayIterator<@T> { [v], 0 };
		}
		return new ArrayIterator<@T> { new @T[0], 0 };
	}
}

extend Maybe<@T> with Optional<@T> {
	@T orElse(@T value) {
		match (this) {
			Just(v) -> return v;
		}
		return value;
	}
	
	@T orElseGet(()->@T getter) {
		match (this) {
			Just(v) -> return v;
		}
		return getter.call();
	}
	
	Bool isPresent() {
		match (this) {
			Just(v) -> return true;
		}
		return false;
	}
}
