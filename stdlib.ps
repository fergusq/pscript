#ifndef _STDLIB_PS
#define _STDLIB_PS

extern Void strcpy(Str d, Str s);
extern Void strcat(Str d, Str s);
extern Void sprintf(Str d, Str f, Int i);

// STRING

model String {
	Str toString();
}

extend Str with String {
	Str toString() {
		return this;
	}
}

extend Int with String {
	Str toString() {
		var str = new Char*(20);
		sprintf(str, "%d", this);
		return str;
	}
}

extend Array<@T> with String {
	Str toString() {
		var str = "[";
		var i = 0;
		for (item in this) {
			if (i != 0) str = str + ", ";
			str = str + item;
			i = i + 1;
		}
		return str + "]";
	}
}

// SUMMABLE

model Summable<@T> {
	$ operator +(@T t);
	@T sumIdentity();
}

extend String with Summable<String> {
	String operator +(String t) {
		return this.toString() + t;
	}
	
	String sumIdentity() {
		return this.sumIdentity();
	}
}

extend Str with Summable<String> {
	Str operator +(String t) {
		var newString = new Char*(this.size()+t.size()+1);
		strcpy(newString, this);
		strcat(newString, t.toString());
		return newString;
	}
	String sumIdentity() {
		return "";
	}
}

// HASSIZE

extern Int strlen(Str s);

model HasSize {
	Int size();
}

extend String with HasSize {
	Int size() {
		return this.toString().size();
	}
}

extend Str with HasSize {
	Int size() {
		return strlen(this);
	}
}

extend Array<@T> with HasSize {
	Int size() {
		return this::len;
	}
}

// APPENDABLE

model Appendable<@T> {
	$ append(@T element);
}

extend Int with Appendable<Int> {
	Int append(Int i) {
		return this + i;
	}
}

extend Array<@T> with Appendable<@T> {
	@T[] append(@T item) {
		var newArray = new @T[this::len+1];
		for (i in fromTo(0, this::len-1)) {
			newArray[i] = this[i];
		}
		newArray[this::len] = item;
		return newArray;
	}
}

// LIST

struct List<@T> {
	@T[] elements;
}

extend List<@T> with HasSize {
	Int size() {
		return this::elements.size();
	}
}

extend List<@T> with String {
	Str toString() {
		return "List { " + this::elements + " }";
	}
}

model MutableList<@T> {
	@T operator [] (Int index);
	Void operator []= (Int index, @T value);
	Void add(@T value);
	@T remove(Int index);
}

extend List<@T> with MutableList<@T> {
	@T operator [](Int index) {
		return this::elements[index];
	}
	Void operator []=(Int index, @T value) {
		this::elements[index] = value;
	}
	Void add(@T value) {
		this::elements = this::elements.append(value);
	}
	@T remove(Int index) {
		var t = this[index];
		var arr = new @T[this.size()-1];
		var i = 0;
		for (v in this::elements) {
			if (i < index)
				arr[i] = v;
			else if (i > index)
				arr[i-1] = v;
		}
		this::elements = arr;
		return t;
	}
}

extend List<@T> with Summable<List<@T>> {
	@T operator +(List<@T> l) {
		var arr = new @T[this.size() + l.size()];
		var i = 0;
		for (v in this::elements) {
			arr[i] = v;
			i = i + 1;
		}
		for (v in l::elements) {
			arr[i] = v;
			i = i + 1;
		}
		return new List<@T> { arr };
	}
	
	List<@T> sumIdentity() {
		return new List<@T> { new @T[0] };
	}
}

#endif
