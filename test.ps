extern Void printf(Str s, Int i);
extern Void sprintf(Str to, Str format, Int i);
extern Void puts(Str s);
extern Int strlen(Str s);

Void printInt(Int i) { printf("%d\n", i); }

// String model

model String {
	Str toString();
}

extend Str with String {
	Str toString() {
		return this;
	}
}

extend Int with String {
	Str toString() {
		var todo = "<TODO>";
		return todo;
	}
}

// HasSize model

model HasSize {
	Int size();
}

extend String with HasSize {
	Int size() {
		return this.toString().size();
	}
}

extend Str with HasSize {
	Int size() {
		return strlen(this);
	}
}

extend Array<@T> with HasSize {
	Int size() {
		return this.length();
	}
}

// Printable model

model Printable {
	Void print();
}

extend Int with Printable {
	Void print() {
		printInt(this);
	}
}

extend Str with Printable {
	Void print() {
		puts(this);
	}
}

extend String with Printable {
	Void print() {
		this.toString().print();
	}
}

// Squarable model

model Squarable {
	$ square();
}

extend Int with Squarable {
	Int square() {
		return this*this;
	}
}

// Duplicable model

model Duplicable {
	$[] duplicate();
}

extend Int with Duplicable {
	Int[] duplicate() {
		return [this, this];
	}
}

// Appendable model

model Appendable<@T> {
	$ append(@T element);
}

extend Int with Appendable<Int> {
	Int append(Int i) {
		return this + i;
	}
}

extend Array<@T> with Appendable<@T> {
	@T[] append(@T item) {
		var newArray = new @T[this.length()+1];
		for (i in fromTo(0, this.length()-1)) {
			newArray[i] = this[i];
		}
		newArray[this.length()] = item;
		return newArray;
	}
}

// Pipe models

model PipeOutput<@T> {
	Void operator |(PipeInput<@T> pipe);
}

model PipeInput<@T> {
	Void consume(@T t);
}

extend Array<@T> with PipeOutput<@T> {
	Void operator |(PipeInput<@T> pipe) {
		for (element in this) {
			pipe.consume(element);
		}
	}
}

extend Int with PipeInput<Int> {
	Void consume(Int i) {
		(this*i).print();
	}
}

struct Printer<@T> { }

extend Printer<@T> with PipeInput<@T> {
	Void consume(@T s) {
		s.print();
	}
}

//

struct List<@T> {
	@T[] elements;
}

extend List<@T> with HasSize {
	Int size() {
		return this::elements.size();
	}
}

model MutableList<@T> {
	@T operator [] (Int index);
	Void operator []= (Int index, @T value);
	Void add(@T value);
	@T remove(Int index);
}

extend List<@T> with MutableList<@T> {
	@T operator [](Int index) {
		return this::elements[index];
	}
	Void operator []=(Int index, @T value) {
		this::elements[index] = value;
	}
	Void add(@T value) {
		this::elements = this::elements.append(value);
	}
	@T remove(Int index) {
		var t = this[index];
		var newList = new @T[this.size()-1];
		var i = 0;
		for (v in this::elements) {
			if (i < index)
				newList[i] = v;
			else if (i > index)
				newList[i-1] = v;
		}
		this::elements = newList;
		return t;
	}
}

//

Int[] fromTo(Int from, Int to) {
	var array = new Int[to-from+1];
	var i = 0;
	for (value in array) {
		array[i] = from+i;
		i = i + 1;
	}
	return array;
}

Void shout(Printable&Squarable p) {
	p.square().print();
	p.square().print();
	p.square().print();
}

Void shoutAll(Printable&Squarable[] ps) {
	for (p in ps) shout(p);
}

Void main() {
	var arr = fromTo(1, 4.append(2));
	for (i in arr) i.square().print();
	shoutAll(arr);
	shoutAll(10.duplicate());
	"---".print();
	"---".size().print();
	[1,2,3].size().print();
	[1,2,3].append(1) | 4;
	//[[1],[2],[3]] | new Printer<Int[]> {};
	var list = new List<Int> { [1, 2, 3] };
	list.add(99);
	list::elements | new Printer<Int> {};
}
